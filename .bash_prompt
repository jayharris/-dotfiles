#!/usr/bin/env bash

# Based on:
# @gf3’s Sexy Bash Prompt, inspired by “Extravagant Zsh Prompt”
# Shamelessly copied from https://github.com/gf3/dotfiles
# Screenshot: http://i.imgur.com/s0Blh.png

if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
	export TERM=gnome-256color
elif infocmp xterm-256color >/dev/null 2>&1; then
	export TERM=xterm-256color
fi

if tput setaf 1 &> /dev/null; then
	tput sgr0
	if [[ $(tput colors) -ge 256 ]] 2>/dev/null; then
		MAGENTA=$(tput setaf 9)
		ORANGE=$(tput setaf 172)
		GREEN=$(tput setaf 190)
		PURPLE=$(tput setaf 141)
		WHITE=$(tput setaf 0)
	else
		MAGENTA=$(tput setaf 5)
		ORANGE=$(tput setaf 4)
		GREEN=$(tput setaf 2)
		PURPLE=$(tput setaf 1)
		WHITE=$(tput setaf 7)
	fi
	BOLD=$(tput bold)
	RESET=$(tput sgr0)
else
	MAGENTA="\033[1;31m"
	ORANGE="\033[1;33m"
	GREEN="\033[1;32m"
	PURPLE="\033[1;35m"
	WHITE="\033[1;37m"
	BOLD=""
	RESET="\033[m"
fi

export MAGENTA
export ORANGE
export GREEN
export PURPLE
export WHITE
export BOLD
export RESET

# check whether printf supports -v
__git_printf_supports_v=
printf -v __git_printf_supports_v -- '%s' yes >/dev/null 2>&1

__scm_prompt() {
    local RED="\033[0;31m"
    local GREEN="\033[0;32m"
    local ORANGE="\033[0;33m"
    local BLUE="\033[0;34m"
    local PURPLE="\033[0;35m"
    local WHITE="\033[0;37m"
    local RESET="\033[m"
    local pcmode=no
	local ps1pc_start='\u@\h:\w '
	local ps1pc_end='\$ '
	local printf_format=' [%s]'

	case "$#" in
		2|3)	pcmode=yes
			ps1pc_start="$1"
			ps1pc_end="$2"
			printf_format="${3:-$printf_format}"
		;;
		0|1)	printf_format="${1:-$printf_format}"
		;;
		*)	return
		;;
	esac

	local git_repo_info hg_repo_info
	git_repo_info="$(git rev-parse --git-dir 2> /dev/null)"
	hg_repo_info="$(hg root 2> /dev/null)"

	if [ -n "$git_repo_info" ]; then
        local index_added=0 index_modified=0 index_deleted=0
        local working_added=0 working_modified=0 working_deleted=0
        local branch_status
        local git_status line x y

        IFS=$'\n'
        git_status="$(git status --branch --porcelain 2> /dev/null)"

        for line in $git_status; do
            x=${line:0:1}; y=${line:1:1};
            if [[ $x = '?' ]]; then
                let working_added++
            elif [[ $x = '#' && $y = '#' ]]; then
                branch_status=${line:3}
            else
                [[ $x = 'A' ]] && let index_added++
                [[ $x = 'M' ]] && let index_modified++
                [[ $x = 'D' ]] && let index_deleted++
                [[ $y = 'M' ]] && let working_modified++
                [[ $y = 'D' ]] && let working_deleted++
            fi
        done

        local status_info="git:";
        if [[ $branch_status =~ "[ahead" ]]; then
            status_info+="\[$GREEN\]"
        elif [[ $branch_status =~ "[behind" ]]; then
            status_info+="\[$ORANGE\]"
        fi
        status_info+=$(echo $branch_status | sed -e 's/\.\{3\}.*//');
        status_info+="\[$RESET\]"

        if [[ index_added -gt 0 || index_modified -gt 0 || index_deleted -gt 0 ]]; then
            status_info+="\[$GREEN\]"
            status_info+=" +$index_added"
            status_info+=" ~$index_modified"
            status_info+=" -$index_deleted"
            status_info+="\[$RESET\]"
        fi
        if [[ working_added -gt 0 || working_modified -gt 0 || working_deleted -gt 0 ]]; then
            status_info+="\[$RED\]"
            status_info+=" +$working_added"
            status_info+=" ~$working_modified"
            status_info+=" -$working_deleted"
            status_info+="\[$RESET\]"
        fi

        if [ $pcmode = yes ]; then
            if [ "${__git_printf_supports_v-}" != yes ]; then
                status_info=$(printf -- "$printf_format" "$status_info")
            else
                printf -v status_info -- "$printf_format" "$status_info"
            fi
            PS1="$ps1pc_start$status_info$ps1pc_end"
        else
            printf -- "$printf_format" "$status_info"
        fi
	elif [ -n "$hg_repo_info" ]; then
        local working_untracked=0 working_added=0 working_modified=0 working_deleted=0 working_missing=0
        local hg_status line x y

        IFS=$'\n'
        hg_status="$(hg status 2> /dev/null)"

        for line in $hg_status; do
            x=${line:0:1};
            [[ $x = '?' ]] && let working_untracked++
            [[ $x = 'A' ]] && let working_added++
            [[ $x = 'M' ]] && let working_modified++
            [[ $x = 'D' ]] && let working_deleted++
            [[ $x = '!' ]] && let working_missing++
        done

        local status_info="hg:$(hg branch 2> /dev/null)"

        if [[ working_untracked -gt 0 || working_added -gt 0 || working_modified -gt 0 || working_deleted -gt 0 || working_missing -gt 0 ]]; then
            status_info+="\[$RED\]"
            status_info+=" ?$working_untracked"
            status_info+=" +$working_added"
            status_info+=" ~$working_modified"
            status_info+=" -$working_deleted"
            status_info+=" !$working_missing"
            status_info+="\[$RESET\]"
        fi

        if [ $pcmode = yes ]; then
            if [ "${__git_printf_supports_v-}" != yes ]; then
                status_info=$(printf -- "$printf_format" "$status_info")
            else
                printf -v status_info -- "$printf_format" "$status_info"
            fi
            PS1="$ps1pc_start$status_info$ps1pc_end"
        else
            printf -- "$printf_format" "$status_info"
        fi
	elif [ $pcmode = yes ]; then
		#In PC mode PS1 always needs to be set
		PS1="$ps1pc_start$ps1pc_end"
	fi
}

PROMPT_COMMAND='__scm_prompt "\u@\h:\w" "\\\$ "'